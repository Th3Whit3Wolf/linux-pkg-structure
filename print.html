<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linux Packaging Structure</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="Introduction/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li><a href="Introduction/glossary.html"><strong aria-hidden="true">1.1.</strong> Glossary</a></li></ol></li><li><a href="Pkg-Fmt/index.html"><strong aria-hidden="true">2.</strong> Package Formats</a></li><li><ol class="section"><li><a href="Pkg-Fmt/alp.html"><strong aria-hidden="true">2.1.</strong> Arch Linux Packages</a></li><li><a href="Pkg-Fmt/deb.html"><strong aria-hidden="true">2.2.</strong> Debian Packages</a></li><li><a href="Pkg-Fmt/gen2.html"><strong aria-hidden="true">2.3.</strong> Gentoo/Sabayon Packages</a></li><li><a href="Pkg-Fmt/rpm.html"><strong aria-hidden="true">2.4.</strong> RPM Packages</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Linux Packaging Structure</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Unsatisified with the current state of Linux OS I have decided to build my own distro with it's own pacakge manager. I have created this book in order to evaluate how current package formats work, what they do well, and where they can make improvements.</p>
<h2><a class="header" href="#terminology" id="terminology">Terminology</a></h2>
<p>In this post I will use several terms that are not explained in the <a href="Introduction/./glossary.html">glossary</a>, this section will (hopefully) explain them so that everyone knows what I mean when I use each of them. If this section, or any other section of this post, is confusing please contact me and tell me. I am afraid I am not perfect, or a mind-reader, so I need you to tell me if something is wrong or if I omitted some important information.</p>
<h3><a class="header" href="#package-building" id="package-building">Package Building</a></h3>
<p><strong>Building a package</strong> will be used to refer to the process of compiling, or otherwise making a package’s source code executable, usually so that some file inside (usually a shell script or file written in object code) can be executed in order to start the program the package is for.</p>
<h3><a class="header" href="#package-installation" id="package-installation">Package Installation</a></h3>
<p>The act of <strong>installing a software package</strong> involves moving the installed files of a package into a file system. Most of the time, when someone says that they are installing a package, what they are doing is they are installing the package’s file to the live file system (that is, the file system of the PC that is being used).</p>
<h3><a class="header" href="#package-preparation" id="package-preparation">Package Preparation</a></h3>
<p>An important step in package development is the <strong>preparation</strong> of the sources being used to build the package.</p>
<h3><a class="header" href="#source-compilation" id="source-compilation">Source Compilation</a></h3>
<p>When one is creating a software package, quite frequently one will need to <strong>compile the package’s source code</strong>, which means convert the source code written in some programming language into something that is machine readable and executable. This conversion is performed, using so called “compilers” like the GNU Compiler Collection (GCC) which creates object code from the source code.</p>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<h2><a class="header" href="#basic-definitions" id="basic-definitions">Basic Definitions</a></h2>
<h3><a class="header" href="#hardware" id="hardware">Hardware</a></h3>
<p>A computer’s <strong>hardware</strong> comprises the physical components of the computer, like its <strong>hard drive</strong> (or <strong>hard disk drive</strong> [<strong>HDD</strong>]) on which information is stored (analogous to a person’s long-term memory), <strong>random-access memory</strong> (<strong>RAM</strong>) devices (analogous to someone’s working memory) and <strong>central processing unit</strong> (<strong>CPU</strong>) or processor (which is where information processing is done, this processing is analogous to a person’s thoughts). The term “computer architecture” or “<strong>instruction set architecture</strong>” (<strong>ISA</strong>) refers to the set of instructions that the CPU, in question, can understand.</p>
<h3><a class="header" href="#software" id="software">Software</a></h3>
<p>A computer’s software are the non-physical components to the computer, which are stored in the computer’s hard drive. It includes the data stored on the hard drive like one’s files as well as the computer programs, which are more or less just instructions for the computer’s processor. For example, as I am writing this post I am using the Atom text editor, which is a computer program.</p>
<h3><a class="header" href="#source-code" id="source-code">Source Code</a></h3>
<p><strong>Source code</strong> is a collection of computer instructions written in at least one human-readable computer language. The type of computer language most frequently-used to write computer programs are so called “programming languages” such as C, C++, Python, etc. Other common computer languages sometimes used to write computer programs (usually alongside programming languages) include markup languages (like HTML and Markdown) and style sheet languages (like CSS). For example, the Atom text editor is written in CoffeeScript, HTML, JavaScript and CSS, where CoffeeScript and JavaScript are programming languages.</p>
<h3><a class="header" href="#free-and-open-source-software" id="free-and-open-source-software">Free and Open-Source Software</a></h3>
<p><strong>Free and open-source software</strong> (<strong>FOSS</strong>) refers to software who’s source code is licensed such that it can freely shared, distributed, studied and even modified and re-released by anyone. FOSS licenses usually require that anyone that modifies and re-releases the source code gives some recognition to the original authors of the source code and some licenses (which are called <strong>copyleft</strong> licenses) even require that the modified source code be released under a similar (if not identical) license to the original source code. The most popular copyleft license is the GNU General Public License (GPL), while the most popular non-copyleft (or <strong>permissive</strong>) FOSS licenses include the BSD licenses and the MIT License.</p>
<h3><a class="header" href="#proprietary-software" id="proprietary-software">Proprietary Software</a></h3>
<p><strong>Proprietary software</strong> (<strong>PS</strong>) refers to software who’s source code is licensed such that it cannot be freely and legally shared. PS is usually, for charge, that is you have to pay to use them. Although some PS is so called “freeware”, in other words, you can use it for free, but you cannot freely and legally access the program’s source code.</p>
<h3><a class="header" href="#fork" id="fork">Fork</a></h3>
<p>A <strong>fork</strong> or <strong>project fork</strong>, is when developers take a copy of the source code from one software project and start independently working on it (or developing it) themselves. In the FOSS world this is commonplace due to the relative lack of restrictions imposed by FOSS licenses.</p>
<h3><a class="header" href="#downstream--upstream" id="downstream--upstream">Downstream / Upstream</a></h3>
<p>The terms <strong>downstream</strong> and <strong>upstream</strong> refers to the direction from and toward the original authors or maintainers of software that is distributed as source code, respectively.</p>
<h3><a class="header" href="#back-end--front-end" id="back-end--front-end">Back-End / Front-End</a></h3>
<p>The terms <strong>back-end</strong> and <strong>front-end</strong> are used together to refer to a relationship between two programs. The front-end program runs the back-end program in the background (often without the user noticing), to perform a specified action (usually package management on this site), but usually the front-end has some higher-level features that it brings to the table, that the back-end program lacks. Quite often, on this site, I will refer to graphical package managers as being front-ends for a command-line package manager, which the graphical package manager will run in the background. What the graphical package manager brings to the table is a more intuitive user interface.</p>
<h3><a class="header" href="#operating-system" id="operating-system">Operating System</a></h3>
<p>An <strong>operating system</strong> (<strong>OS</strong>) is the base set of system software that forms the foundation for other programs to run on top of. It manages all communication between the computer’s hardware and the application software that run on top of it. At its heart, each OS has what is known as a kernel, which manages all communication with the computer’s hardware. Notable examples of operating systems, include:</p>
<ul>
<li>FreeBSD</li>
<li>Linux</li>
<li>Mac OS</li>
<li>MS-DOS</li>
<li>OS X</li>
<li>Windows 1.0 to Windows ME (including Windows 95 and 98)</li>
<li>Windows NT (including Windows XP, Vista, 7, 8, 10, etc)</li>
</ul>
<h3><a class="header" href="#kernel" id="kernel">Kernel</a></h3>
<p>An operating system <strong>kernel</strong> is the piece of system software that manages all communication between a computer’s hardware and its software. Most kernels also perform virtual memory allocation. Some of this virtual memory is allocated to the kernel (which is called <strong>kernel mode</strong>), the rest is allocated to the user’s processes (or <strong>user mode</strong>, application software run in user mode). It is in many ways the operating system’s brain, without it the OS will not work. There are three main types of operating system kernel, based on their respective design:</p>
<ul>
<li>
<p><strong>Hybrid kernel</strong> — as its name suggest it is mid-way between the below designs. Examples include the kernels of OS X and Windows NT. Linus Torvalds, the lead and original developer of the Linux kernel, amongst others, believe that the <strong>hybrid kernel</strong> category is purely marketing and that these kernels fit quite easily into one of the following two categories.</p>
</li>
<li>
<p><strong>Microkernel</strong> (or <strong>μkernel</strong>) — kernels that keep as few processes running in kernel mode as possible. They, as their name suggest, usually do the bare minimum needed of a kernel. Consequently, the number of lines of code in their source code is usually substantially less than their monolithic counterparts. Extreme variants of microkernels include nanokernels and picokernels, which have even fewer lines of source code. The most notable example is MINIX.</p>
</li>
<li>
<p><strong>Monolithic kernel</strong> — these are kernels that perform all operating system functions in kernel mode. They usually consist of far more lines of code than their microkernel counterparts. The most notable examples are the FreeBSD, Linux, NetBSD and OpenBSD kernels.</p>
</li>
</ul>
<p>Microkernels are easier for software developers to work on and are supposedly more easily portable to additional instruction set architectures (ISAs). Despite this, the monolithic Linux kernel has been ported to the greatest number of ISAs of any operating system kernel.</p>
<h3><a class="header" href="#unix" id="unix">Unix</a></h3>
<p><strong>Unix</strong> (or <strong>UNIX</strong> for the trademark) is a family of operating systems that share several common characteristics and are certified as being compliant to at least one version of the <strong>Single UNIX Specification</strong> (<strong>SUS</strong>). These common characteristics are best summarized with what is sometimes called the “<strong>Unix philosophy</strong>”. The Unix philosophy is that the operating system provides a set of simple command-line tools or utilities (which I will sometimes refer to as Unix utilities) that perform a limited, well-defined function, which usually involves manipulating components (like files) in the unified file system that is also characteristic of Unix systems. Additionally Unix systems also have what is known as a command language or shell scripting language, called a <strong>Unix shell</strong>, with which users can call on these simple tools. Unix is also notable in that it is designed to be easily portable to a variety of different computers (distinguished from one another, mostly by the details of their CPU).</p>
<h3><a class="header" href="#unix-like" id="unix-like">Unix-like</a></h3>
<p>A <strong>unix-like</strong> operating system is one that behaves and to all the world seems like a Unix system, despite not being certified compliant to any version of the SUS. These systems can also be referred to as Unix clones. The only real practical difference between Unix and Unix-like systems are that Unix systems are usually developed by a commercial entity with the funds required to get their system SUS-certified.</p>
<h3><a class="header" href="#nix" id="nix">*nix</a></h3>
<p><strong>*nix</strong> is my shorthand way of referring collectively to both Unix and Unix-like systems. Despite this, you will also see other authors, including those that know far more than I do about these systems, using *nix to refer to just Unix-like systems.</p>
<h3><a class="header" href="#linux" id="linux">Linux</a></h3>
<p><strong>Linux</strong> is a large family of Unix-like operating systems (its members are referred to, collectively, as Linux distributions) that share one common defining characteristic: they use the Linux kernel as their kernel. The Linux kernel is a predominantly free and open-source kernel developed by Linus Torvalds who first started developing the kernel in 1991 when he was a 21-year-old computer science student studying at the University of Helsinki in Finland. I used the phrasing “predominantly free and open-source” deliberately, as while most of the kernel’s source code is licensed under the GNU GPL, there are some binary blobs on the kernel (which mostly just add to its compatibility with available hardware) that are not free and open-source.</p>
<h3><a class="header" href="#gnu" id="gnu">GNU</a></h3>
<p>The <strong>GNU Project</strong> is a FOSS project that was first founded in the 1980s by Richard M. Stallman (or rms), its stated mission is to develop a free and open-source Unix clone. This clone is referred to as GNU, which is incredibly unpopular. The GNU Project provides the Unix utilities (contained in the GNU Coreutils package) and the Unix shell (called Bash) used by the vast majority of Linux distributions. Due to this some people refer to the family of operating systems known as Linux, as GNU/Linux.</p>
<h3><a class="header" href="#free-software-foundation" id="free-software-foundation">Free Software Foundation</a></h3>
<p>The <strong>Free Software Foundation</strong> (<strong>FSF</strong>) non-profit organization set up by Stallman that advocates the widespread use of FOSS and was originally set up to hire people to develop software for the GNU Project. The FSF also provides its own set of predominantly copyleft licenses which includes the GNU GPL mentioned earlier.</p>
<h3><a class="header" href="#linux-libre" id="linux-libre">Linux-libre</a></h3>
<p>The <strong>Linux-libre kernel</strong> is essentially the Linux kernel with its binary blobs removed. This makes the kernel entirely free and open-source, as these binary blobs are proprietary software. A comparatively small number of Linux distributions use the libre kernel, these distributions are often called GNU/Linux-libre distributions and are fairly unpopular compared to their non-libre counterparts.</p>
<h3><a class="header" href="#berkeley-software-distribution" id="berkeley-software-distribution">Berkeley Software Distribution</a></h3>
<p>The <strong>Berkeley Software Distribution</strong> (<strong>BSD</strong>) is a Unix operating system that was developed at the University of California, Berkeley between 1977 and 1995. It was originally closed-source (that is, not open-source), but later releases were licensed under permissive BSD licenses. Since then several descendants of BSD have emerged with the most notable and popular one being FreeBSD. I use the terminology *BSD to collectively refer to BSD and its descendants.</p>
<h3><a class="header" href="#file-archive" id="file-archive">File Archive</a></h3>
<p>A <strong>file archive</strong> is a type of file, that stores one or more files, potentially with associated metadata, in a more portable and easily-compressed format. On Linux and other *nix systems, the most common type of file archive is a tar archive (which have the <code>.tar</code> file extension), with rar archives (file extension: <code>.rar</code>) being a popular alternative, especially for non-Linux platforms such as Windows. <code>tar</code> is a basic Unix utility, the specifics of this utility, its syntax, supported file formats, etc. is dependent on the *nix system it belongs to. Most Linux distributions use GNU tar as their default tar utility, but also have FreeBSD’s tar (usually called by the <code>bsdtar</code> command) utility available from their software repositories.</p>
<h3><a class="header" href="#software-package" id="software-package">Software Package</a></h3>
<p>Software packages are distributions (or packages) of software and data contained within a file archive. This archive is sometimes compressed so as to save space and make them easier to transfer over a network. Software packages usually also contain some metadata, that is, information about the contents of the package. Example software package formats include:</p>
<ul>
<li>Debian package format (file extension: <code>.deb</code>) — used by Debian’s dpkg package manager. They are archives created using the Unix <code>ar</code> utility.</li>
<li>pacman package format (file extension: <code>.pkg.tar.xz</code>) — used by Arch Linux and other Linux distributions using the pacman package manager. They are xz-compressed tar archives.</li>
<li>RPM package format (file extension: <code>.rpm</code>) — used by Red Hat’s RPM package manager.</li>
</ul>
<h3><a class="header" href="#package-management-system" id="package-management-system">Package Management System</a></h3>
<p>A <strong>package management system</strong> (<strong>PMS</strong>, plural form: <strong>PMSs</strong>) or <strong>package manager</strong> is a collection of system software that automates the process of installing, configuring, removing and upgrading software packages. Traditionally Linux PMSs were operated solely from the command-line but nowadays several graphical PMSs also exist.</p>
<h3><a class="header" href="#software-repository" id="software-repository">Software Repository</a></h3>
<p>A <strong>software repository</strong> is essentially an archive of software packages from which package managers can download said packages and then install them.</p>
<h3><a class="header" href="#linux-distribution" id="linux-distribution">Linux Distribution</a></h3>
<p>A <strong>Linux distribution</strong> (<strong>LD</strong> or <strong>distro</strong>) is an individual, specific, operating system that uses the Linux kernel (that is, a specific member of the Linux family of operating systems). Most Linux distributions use GNU Project software for their Unix utilities, hence meaning that most Linux distributions can also be called <strong>GNU/Linux distributions</strong>. An LD consists of, at least, the following basic components:</p>
<ul>
<li>The <strong>Linux kernel</strong> (or the <strong>Linux-libre kernel</strong>, in some cases)</li>
<li><strong>GNU Project software</strong>, such as Bash, the coreutils package, glibc, <em>etc</em>.</li>
<li>A <strong>package management system</strong>, such as APT, DNF, Entropy, pacman, Portage, <em>etc</em>.</li>
</ul>
<h3><a class="header" href="#software-version-nomenclature" id="software-version-nomenclature">Software Version Nomenclature</a></h3>
<p>In the field of software development, software releases are usually distinguished from one another by use of a numbering scheme. Each project has a different numbering scheme. The most common scheme is of the form:</p>
<ul>
<li><code>x.y.z</code>. <code>x</code>, <code>y</code> and <code>z</code> are all natural numbers (that is, <code>x</code>, <code>y</code>, <code>z</code> ∈ <code>{0, 1, 2, 3, ...}</code>). <code>x</code> is the major version of the software. Major versions have major feature differences in them, for example, the 4.0 Linux kernel had far more features than the 3.0 version of the Linux kernel. <code>y</code> is the minor version of the software. Minor software releases (where the only difference is the minor version number of the software. For example 4.6.0 is one minor release ahead of 4.5.0) usually only differ by a few, often minor features. <code>z</code> is the patch (or bug-fix) version of the software. If you are sick of my algebra I will give you an example of a program that follows this versioning scheme: the Linux kernel. An example version of the kernel is the 4.9.6 kernel. 4 is the major version, 9 is the minor version and 6 is the patch version.</li>
</ul>
<h3><a class="header" href="#release-models-fixed-vs-rolling" id="release-models-fixed-vs-rolling">Release Models: Fixed vs. Rolling</a></h3>
<p>In the context of operating system development, there are two main types of release model: fixed and rolling. The most popular of these is the fixed <strong>release model</strong>, with the rolling release model being mostly used by bleeding edge operating systems geared towards advanced users like Arch Linux and Gentoo Linux.</p>
<p>Operating systems that follow a <strong>fixed release model</strong> (<strong>FRM</strong>) have fixed releases, which users are required to upgrade to, in order to keep their system up-to-date. This upgrade process can be (1) via downloading or otherwise acquiring the installation media for the latest version and going through its installer, or (2) via the distribution’s package manager or other methods (e.g., Ubuntu uses the <code>do-release-upgrade</code> command). These upgrades usually include major updates for several pieces of software, including core system components like the kernel, C libraries, compilers, core utilities, etc. In my experience, this process takes hours, uses up a lot of bandwidth and usually breaks at least one program on one’s system. This is why I, personally, are not a big fan of systems following a FRM.</p>
<p>Systems following a <strong>rolling release model</strong> (<strong>RRM</strong>) have no fixed releases, rather software updates, including major ones, simply become available for installation as soon as they have been packaged by the repository’s maintainers.</p>
<h3><a class="header" href="#virtualization" id="virtualization">Virtualization</a></h3>
<p><strong>Virtualization</strong> is the act of creating a virtual (rather than actual) version of something. Most commonly this “something” is an operating system. Virtualization is usually performed using computer programs that can be referred to as virtualization programs. In this context, the <strong>host</strong> is the computer being used to run the virtualization program, while the <strong>guest</strong> is the virtual system being run. For example, I am presently typing this glossary section on Arch Linux, so if I fire up a CentOS 7 VM in Oracle VM VirtualBox, then my host operating system would be Arch Linux and my guest operating system would be CentOS 7.</p>
<h3><a class="header" href="#cross-distribution-package-formats" id="cross-distribution-package-formats">Cross-Distribution Package Formats</a></h3>
<p>A <strong>cross-distribution package format</strong> (<strong>CDPF</strong>; plural form is <strong>CDPFs</strong>) are a type of Linux software package format that are designed to run on most, if not all, Linux distributions. There are four main, distinct CDPFs I am aware of:</p>
<ul>
<li>
<p><a href="http://appimage.org/"><strong>AppImage</strong></a> (previously known as <strong>klik</strong>), a type of self-mounting image file (created using SquashFS) that contains all the libraries, executables, desktop configuration files, icon files, <em>etc</em>. used by the application it provides. They need no root privileges in order to be run and need no special package manager of their own, as unlike most package formats they are not installed. They are distinct from other CDPFs as they are not installed and unlike binary archives they need not be extracted in order to be run. They merely need to be marked as executable (with <code>chmod +x</code>) and run (with <code>./&lt;AppImage&gt;</code> where <code>&lt;AppImage&gt;</code> is the name of the AppImage, including its file extension. I have built quite a few AppImages, usually with the help of <a href="https://github.com/probonopd">Simon Peter</a>, the creator of this package format.</p>
</li>
<li>
<p><strong>Binary archives</strong>, which have been aroud for decades are essentially archives (usually zipped or otherwise compressed) which contain all the libraries and executables required to run the program they provide on Linux. They need to be extracted in order for the program contained within to be run. SageMath and Scilab are both programs that are distributed like this.</p>
</li>
<li>
<p><a href="http://flatpak.org/"><strong>Flatpak</strong></a> (previously known as <strong>xdg-app</strong>), a package format best supported (but not officially supported by) by the Fedora (for example, the <code>flatpak</code> package is in the official Fedora repositories) Linux distribution and the GNOME desktop environment. Most GNOME applications are officially available as Flatpaks. GNOME Software (a graphical front-end for package management) also has support for Flatpaks as of the 3.22.0 release. Flatpaks are installed using a package manager also known as Flatpak and called by the command <code>flatpak</code>. As one can probably guess one has to install the Flatpak package manager using your distribution’s respective package manager (e.g., APT, DNF, pacman, URPMI, Yum, ZYpp) in order to use it to install Flatpak packages. The only distributions I know of with Flatpak in its official repositories are: Arch Linux, Fedora and Manjaro Linux. CentOS, Debian, Gentoo, openSUSE and Ubuntu users have to use unofficial repositories in order to install it. Like most package managers, Flatpak requires administrative privileges in order to be run. Flatpaks are perhaps the most challenging package format to build, in my opinion.</p>
</li>
<li>
<p><a href="http://snapcraft.io/"><strong>Snap</strong></a>, a package format officially developed by Canonical Ltd, the same company responsible for the development of the Ubuntu operating system. Like Flatpak it also requires its own package manager to be installed in order for one to run them. This package manager is written in Google’s Go programming language (which was first publically released in 2009, so it is fairly new). Snap packages are built using a program called <code>snapcraft</code> which is written in Python. The source files used to tell <code>snapcraft</code> how to build Snap packages and the metadata to include with them are yaml files that often call on plugins (written in Python) in order to build the Snap package. I have never built a Snap package from scratch as I do not understand Python well enough to write my own plugins, but I have managed to create custom packages using existing source files.</p>
</li>
</ul>
<h3><a class="header" href="#governance" id="governance">Governance</a></h3>
<p>In the context of open-source projects, the term <strong>governance</strong> refers to how the project is governed or lead. Some projects are <strong>authoritarian</strong> in governance, in other words they are dictatorships, with a single leader in charge. A notable example of such a project is the Slackware Linux Project. Others are <strong>donation-sponsored democracies</strong>, wherein the volunteer developers of the project usually have the power to make decisions via consensus. Likewise others are <strong>company-sponsored semi-democracies</strong>, wherein a company sponsors the project and has some say over decisions, but the majority of the authority to make decisions about the project resides with the community of volunteer developers (or so it should, whether it does in practise is something I will likely not know until I work in one).</p>
<h2><a class="header" href="#acronyms" id="acronyms">Acronyms</a></h2>
<blockquote>
<p><strong>NOTE</strong></p>
<blockquote>
<ul>
<li><em>Acronyms covered in the previous sections are not repeated in this list.</em></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><em>Hyperlinks are to sources that explain, in greater detail, the term.</em></li>
</ul>
</blockquote>
</blockquote>
<ul>
<li><strong>ABS</strong>: <a href="https://wiki.archlinux.org/index.php/Arch_Build_System"><strong>Arch Build System</strong></a>, a system whereby all the PKGBUILDs, patch files and assorted other files used to build packages in the pacman repositories are stored in subdirectories of /var/abs. It is essentially Arch’s equivalent to the Portage Tree.</li>
<li><strong>AUR</strong>: <a href="https://wiki.archlinux.org/index.php/Arch_User_Repository"><strong>Arch User Repository</strong></a>, a repository of Arch user-supplied PKGBUILDs, patch files and assorted other files that, while they are not used to build any packages in the pacman repositories, can (provided they do not have any bugs preventing them from building successfully, that is) be used to build Arch packages locally (on their own Arch machine) by users.</li>
<li><strong>Deb</strong>: the package format used by Debian’s dpkg package manager.</li>
<li><strong>PC</strong>: <strong>Personal computer</strong>. Can be a desktop or laptop, does not matter if it once ran OS X or Windows, still to me it is a PC.</li>
<li><strong>RPM</strong>: <a href="http://rpm.org/"><strong>RPM Package Manager</strong></a>, originally <strong>Red Hat Package Manager</strong>. This is the name of both a package manager and the package format used by this package manager.</li>
</ul>
<h1><a class="header" href="#package-formats" id="package-formats">Package Formats</a></h1>
<p>In order to effectively build packages one must understand the basics of the <strong>package format</strong> one intends to build. There are four major types of Linux package format that I worked with:</p>
<ul>
<li><strong>Arch Linux packages</strong> (<strong>ALPs</strong>, file extension: <code>.pkg.tar.xz</code>), the package format used by Arch Linux, its derivatives and select “independent” distributions such as Frugalware Linux and KaOS. They are built based on the contents of PKGBUILDs, which are Bash scripts with build instructions for the package along with its associated metadata.</li>
<li><strong>Debian packages</strong> (or <strong>Deb packages</strong>, file extension: <code>.deb</code>), the package format used by Debian and its derivatives such as Ubuntu and its derivative, Linux Mint. They are built based on the contents of a whole directory and its subdirectories. The build instructions are found within the <code>rules</code> file.</li>
<li><strong>Gentoo packages</strong> (file extension: <code>.tbz2</code>), the package format used by Gentoo Linux and its derivatives like Sabayon Linux. tbz2 files are built based on the contents of a specialized Bash script called an ebuild (with the <code>.ebuild</code> file extension). ebuilds are stored within a set of directories and subdirectories (called <strong>overlays</strong>), usually managed by Git (<code>git</code>) or some other version control system (VCS) like Mercurial (<code>hg</code>) or Subversion (<code>svn</code>). They are essentially like more complicated (and hence more difficult to write) equivalents to PKGBUILDs and like PKGBUILDs they include package metadata and build instructions.</li>
<li><strong>RPM packages</strong> (file extensions: <code>.rpm</code>, <code>.src.rpm</code>), a package format used by select distributions such as CentOS, Fedora, Mageia and openSUSE. They are built based on the contents of a whole directory, entitled <code>rpmbuild</code>, and its subdirectories. The most important file in the <code>rpmbuild</code> directory and its subdirectories is called a spec file, which has the <code>.spec</code> file extension. This spec file contains package metadata and build instructions, similarly to ebuilds and PKGBUILDs.</li>
</ul>
<h1><a class="header" href="#arch-linux-packages" id="arch-linux-packages">Arch Linux Packages</a></h1>
<p><strong>Arch Linux packages</strong> are xz-compressed tar archives that are built and installed using commands provided by the <code>pacman</code> package on Arch Linux. ALPs are the package format used by Arch Linux derivatives (like Manjaro Linux) along with the “independent” distributions, Frugalware Linux and KaOS, which also use the pacman package manager, so this information should be applicable to packaging on these distributions too.</p>
<h3><a class="header" href="#alp-contents" id="alp-contents">ALP Contents</a></h3>
<p>ALPs have the following contents:</p>
<pre><code class="language-sh">$INSTALLED_FILES
.BUILDINFO
.INSTALL
.MTREE
.PKGINFO
</code></pre>
<p>where <code>$INSTALLED_FILES</code> are, of course, the installed files of the package with its respective file structure. For example, for the <code>broadcom-wl</code> package the <code>$INSTALLED_FILES</code> have the directory structure:</p>
<pre><code class="language-sh">usr/
 - lib/
   - modprobe.d/
     - broadcom-wl.conf
   - modules/
     - extramodules-4.4-ARCH/
       - wl.ko.gz
 - share/
   - licenses/
     - broadcom-wl/
       - LICENSE
</code></pre>
<p>The package metadata (which is used by pacman when it installs new packages to check for file conflicts and such) is stored in the four hidden files (that is, those with . in their filename) in the package’s top-level directory.</p>
<h3><a class="header" href="#pkgbuild-structure" id="pkgbuild-structure">PKGBUILD Structure</a></h3>
<p>ALPs are built from PKGBUILDs using the <code>makepkg</code> command that comes bundled with the pacman package manager. They are the easiest packages to build, in my opinion. PKGBUILDs have the following general format (for more details see the <a href="https://fusion809.github.io/man/PKGBUILD.5.html">PKGBUILD(5)</a> man page):</p>
<pre><code class="language-sh"># ~ Maintainer/Contributor name and email ~
pkgname=      # The package's name.
pkgver=       # The upstream package version, e.g., 1.5.0 for Atom 1.5.0.
pkgrel=       # The PKGBUILD revision number.
pkgdesc=      # The PKGBUILD's description.
arch=         # The architecture(s) on which the package is to be built.
url=          # The website of the package.
license=      # The legal license of the package.
depends=      # Runtime dependencies.
makedepends=  # Build dependencies.
optdepends=   # Optional dependencies.
provides=     # What the package provides.
conflicts=    # The package conflicts.
source=       # The source files required; also includes patches.
sha256sums=   # SHA256 sums of the source files.
md5sums=      # MD5 sums of the source files. Usually used INSTEAD of sha256sums.
install=      # Install files.

prepare() {   # Prepare the sources. Most commonly you will find sed functions
}             # and patches being applied here.

build() {     # Perform any compiling of the source code that may be necessary.
}             # You may also see configure scripts being run here.

package() {   # This will actually build the package. If more than one package is
}             # built from the one PKGBUILD then more than one package() function is provided.
</code></pre>
<p>the <code>sha256sums</code> can be replaced with <code>sha512sums</code> and sometimes GPG signatures are used also. For example, the Linux kernel PKGBUILD, in the core pacman repository, uses GPG and sha256sums to check package integrity and validity. The variable definition lines (that is, the <code>pkgname</code> line through to <code>install</code> line) provide mostly the package’s metadata and security checks (as well as variables that can be used in the following functions), while the <code>prepare(),</code> <code>build()</code> and <code>package()</code> functions are responsible for the actual building of the package. The <code>install</code> line defines the <code>.install</code> file that contains pre-, peri- and post-install checks and functions that need to be executed for the package. Here is an example PKGBUILD I have used to build gVim 7.4.1525:</p>
<pre><code class="language-sh"># Maintainer: Brenton Horne &lt;brentonhorne77 at gmail dot com&gt;
# Contributor: Peter Mattern &lt;pmattern at arcor dot de&gt;

_pkgname=vim
pkgname=&quot;gvim&quot;
pkgver=7.4.1525
pkgrel=1
pkgdesc=&quot;Vim the editor. CLI version and GTK2 GUI providing majority of features.&quot;
arch=(&quot;i686&quot; &quot;x86_64&quot;)
url=&quot;http://www.vim.org&quot;
license=(&quot;custom:vim&quot;)
depends=(&quot;gtk2&quot; &quot;hicolor-icon-theme&quot; &quot;gtk-update-icon-cache&quot; &quot;desktop-file-utils&quot;)
optdepends=(&quot;lua: Lua interpreter&quot; &quot;perl: Perl interpreter&quot; &quot;python: Python 3 interpreter&quot;
            &quot;python2: Python 2 interpreter&quot; &quot;ruby: Ruby interpreter&quot;)
makedepends=(&quot;lua&quot; &quot;python&quot; &quot;python2&quot; &quot;ruby&quot;)
provides=(&quot;gvim&quot; &quot;xxd&quot; &quot;vim-runtime&quot;)
conflicts=(&quot;vim-minimal-git&quot; &quot;vim-git&quot;
           &quot;vim-minimal&quot; &quot;vim&quot; &quot;vim-python3&quot; &quot;gvim&quot; &quot;gvim-python3&quot;)
source=(&quot;https://github.com/vim/vim/archive/v$pkgver.tar.gz&quot;
        &quot;gvim.desktop&quot;)
sha256sums=('SKIP'
            'c346da4725b2db6f7b58c5b72bdf9e7efbba2a3275e97c17db48689e4de674ca')
install=gvim.install

prepare() {

    # set global configuration files to /etc/[g]vimrc
    sed -i 's|^.*\(#define SYS_.*VIMRC_FILE.*&quot;\) .*$|\1|' ${srcdir}/${_pkgname}-${pkgver}/src/feature.h

}

build() {

    cd &quot;${srcdir}/${_pkgname}-${pkgver}&quot;
    ./configure \
      --enable-fail-if-missing \
      --with-compiledby='Arch Linux AUR' \
      --prefix=/usr \
      --enable-gui=gtk2 \
      --with-features=huge \
      --enable-cscope \
      --enable-multibyte \
      --enable-perlinterp=dynamic \
      --enable-pythoninterp=dynamic \
      --enable-python3interp=dynamic \
      --enable-rubyinterp=dynamic \
      --enable-luainterp=dynamic
    make

}

package() {

    # actual installation
    cd &quot;${srcdir}/${_pkgname}-${pkgver}&quot;
    make DESTDIR=$pkgdir install

    # desktop entry file and corresponding icon
    install -D -m644 ../gvim.desktop      $pkgdir/usr/share/applications/gvim.desktop
    install -D -m644 runtime/vim48x48.png $pkgdir/usr/share/icons/hicolor/48x48/apps/gvim.png

    # remove ex/view and man pages (normally provided by package 'vi' on Arch Linux)
    cd $pkgdir/usr/bin ; rm ex view
    find $pkgdir/usr/share/man -type d -name 'man1' 2&gt;/dev/null | \
      while read _mandir; do
        cd ${_mandir}
        rm -f ex.1 view.1
      done

    # add license
    install -D -m644 ${srcdir}/${_pkgname}-${pkgver}/runtime/doc/uganda.txt \
      $pkgdir/usr/share/licenses/$pkgname/LICENSE
}
</code></pre>
<p><code>prepare()</code> is used to <em>prepare</em> the source, which means if the source is compressed (like a gz-compressed tar archive) the <code>prepare()</code> function will exact its contents so that they are available for the <code>build()</code> and <code>package()</code> functions. <code>build()</code> is used to build, or compile, the source, that is if this needs to be done (for example, some PKGBUILDs actually build ALPs from Debian or RPM packages, so no source code compiling is required). <code>package()</code> is what builds a package from either the compiled source (that is, the source after the <code>build()</code> function is run) or the prepared pre-compiled sources (that is, the contents of Debian/RPM binaries).</p>
<p>The <code>package()</code> function is essentially where the objective of the game is to move all the files you wish to be in the end package from the products (whether it be compiled source code, or unpacked Debian package contents) of the <code>build()</code> function into the <code>$pkgdir</code> directory. The <code>$pkgdir</code> directory is meant to have the same internal file system structure as where the package will place its installed files, if installed on one’s file system. For example, GTK themes are usually installed to <code>/usr/share/themes</code> so this is an example <code>package()</code> function for such cases (this one is specifically taken from the <code>osx-el-capitan-theme</code> PKGBUILD):</p>
<pre><code class="language-sh">package() {
  mkdir -p &quot;$pkgdir/usr/share/themes/&quot;
  cp -a &quot;$srcdir/${_pkgname}-${pkgver}/OS X El Capitan&quot; &quot;$pkgdir/usr/share/themes/&quot;
}
</code></pre>
<p>see the package’s contents are moved to <code>${pkgdir}/usr/share/themes/OS X El Capitan</code>.</p>
<h3><a class="header" href="#building-alps" id="building-alps">Building ALPs</a></h3>
<p>To build an ALP you run:</p>
<pre><code class="language-sh">user $  makepkg
</code></pre>
<p>from within the same directory, as the PKGBUILD you intend to build is located. You may not have the package’s build dependencies pre-installed so this command may return an error stating that you have missing build dependencies. To fix this (assuming all the dependencies are in the presently-enabled pacman repositories) by installing all required build dependencies prior to the build, run:</p>
<pre><code class="language-sh">user $  makepkg -s
</code></pre>
<h1><a class="header" href="#debian-packages" id="debian-packages">Debian Packages</a></h1>
<p>The Debian package format (file extension: <code>.deb</code>) was one of the first Linux package formats developed. It was first developed by Ian Murdock and other members of the Debian development team. The package manager that was originally developed to work with Debian packages (installing, uninstalling, upgrading, etc. these packages) was called dpkg (invoked by the <code>dpkg</code> command), while APT, aptitude and Synaptic are front-ends that perform repository management, dependency resolution, etc. and then use dpkg to perform the actual installation of Debian packages. Debian packages are built based on the contents of several different files in a directory (with its own set file structure, including subdirectories and alike) entitled debian. Debian packages are <code>ar</code> archives, that is archives generated with the ar Unix utility. They are built using the <code>debuild</code> or <code>dpkg-buildpackage</code> commands that are provided by the <code>devscripts</code> package, which is separate from the package that provides the <code>dpkg</code> command.</p>
<h3><a class="header" href="#package-contents" id="package-contents">Package Contents</a></h3>
<p>As previously mentioned, Debian packages are ar archives and they have the following three files inside them:</p>
<pre><code class="language-sh">debian-binary
control.tar.xx
data.tar.xx
</code></pre>
<p>where <code>.xx</code> denotes the compression file extension of the containing files. Most Debian packages use gz-compression for its control and data tar archives, so in this case <code>.xx</code> is replaced with <code>.gz</code>. Some Debian packages have xz-compressed control and data tar archives inside them. The <code>debian-binary</code> file is a plain text file containing the standard number of the Debian package (e.g., the latest is 3.0). The <code>control.tar.xx</code> archive contains the package’s metadata, while the <code>data.tar.xx</code> archive contains the package’s installed files.</p>
<h3><a class="header" href="#build-directory-structure" id="build-directory-structure">Build Directory Structure</a></h3>
<p>The <code>debian</code> directory used to build Debian packages, has the structure:</p>
<pre><code class="language-sh">debian/
  - changelog
  - compat
  - control
  - copyright
  - rules
  - source/
    - format
</code></pre>
<p>The <code>changelog</code> and <code>copyright</code> files have pretty self-explanatory contents, so I will not bother describing their contents. The <code>compat</code> file has the number nine (9) in it, because allegedly it is a “magic number”. The <code>control</code> file contains the package metadata, like its description, name, version, dependencies, etc. The <code>rules</code> file contains the package build instructions. The <code>format</code> file contains the standard of the Debian package being described, for example, most packages at the moment will be using the 3.0 (quilt) standard.</p>
<h1><a class="header" href="#gentoosabayon-packages" id="gentoosabayon-packages">Gentoo/Sabayon Packages</a></h1>
<p><strong>Gentoo packages</strong> (file extension: <code>.tbz2</code>) are bz2-compressed binary packages used by Gentoo Linux and its derivatives. They are produced and installed using the Portage package manager. <strong>Sabayon Linux</strong>’s Entropy package manager uses a slightly different package format (same file extension though, <code>.tbz2</code>), generated from the corresponding Gentoo packages using Entropy. Most Gentoo users will not install their software from tbz2 files, as Portage is a source code package manager (which is usually the reason why people use Gentoo in the first place, because they want to install packages from source code using Portage) and as a result most packages are built from source code and not installed from binary packages. The way that Portage installs software from source code is by following the instructions found in a specialized Bash script called an ebuild. Portage can be used to install tbz2 binary packages, however, and it can be configured to work with (that is, install, remove, upgrade, etc. packages in said repositories) binary package repositories. This is just an uncommon Portage configuration.</p>
<h3><a class="header" href="#package-contents-1" id="package-contents-1">Package Contents</a></h3>
<p>Running:</p>
<pre><code class="language-sh">user $  qtbz2 $package.tbz2
</code></pre>
<p>where <code>$package.tbz2</code> is a tbz2 binary, extracts an xpak file (file extension: <code>.xpak</code>; which contains the package metadata) and <code>.tar.bz2</code> archive containing the installed files of the package.</p>
<h3><a class="header" href="#ebuild-structure" id="ebuild-structure">ebuild Structure</a></h3>
<p>Syntactically, I would say that ebuilds are most similar to PKGBUILDs, but there are several key differences. For one, they include eclasses, specialized Bash functions designed specifically for ebuilds, many of which are poorly documented, in my opinion. Secondly, PKGBUILDs are all named <code>PKGBUILD</code>, while ebuilds only share the same file extension <code>.ebuild</code>. Their name consists of the package’s name and its version, e.g., gVim 7.4.1342 would have an ebuild named <code>gvim-7.4.1342.ebuild</code>. ebuilds also come with manifests (files entitled <code>Manifest</code>) that include checksums for all the source files and the ebuilds themselves. Here is an ebuild for gVim that you can compare to the previously-provided PKGBUILD and spec file for gVim, it is over 400 lines long so I am not going to include it in this post. To build a Gentoo binary package from an ebuild run:</p>
<pre><code class="language-sh">user $  ebuild $package.ebuild package
</code></pre>
<p>while to build a Sabayon binary package, one has to run one additional command:</p>
<pre><code class="language-sh">root #  equo pkg inflate $package.tbz2
</code></pre>
<h1><a class="header" href="#rpm-packages" id="rpm-packages">RPM Packages</a></h1>
<p>RPM Packages (file extension: <code>.rpm</code>, source RPMs have the <code>.src.rpm</code> file extension) are the package format used by Red Hat Linux (RHL), its derivatives (such as CentOS, Fedora, Korora, Oracle Linux, Red Hat Enterprise Linux, Scientific Linux), openSUSE, SUSE Linux Enterprise, etc. They are built using the <code>rpmbuild</code> command provided by the <code>rpmdevtools</code> package on most distributions. From what I understand RPMs are a type of file archive (which can be extracted using the <code>bsdtar</code> or <code>rpm2cpio</code> commands). They are not <code>ar</code> archives, however. RPM is a binary package format, although a source code version also exists, which is called a SRPM. SRPMs can also be extracted using <code>bsdtar</code>.</p>
<h3><a class="header" href="#rpm-contents" id="rpm-contents">RPM Contents</a></h3>
<p>Decompressing RPM packages using <code>user $ bsdtar -xf $package.rpm</code> extracts just the package’s installed files. This might make it seem like RPM packages have no metadata, but they do, it is just not readily apparent by decompressing them using <code>bsdtar</code>. To show a summary of the metadata inside these packages you need to run <code>user $ rpm -qip $package.rpm</code>.</p>
<h3><a class="header" href="#rpmbuild" id="rpmbuild">rpmbuild</a></h3>
<p><code>rpmbuild</code> needs to be run within a directory called <code>rpmbuild</code> within the current user’s home directory, with its own set of subdirectories, this is its general structure:</p>
<pre><code class="language-sh">rpmbuild/
  - BUILD
  - BUILDROOT
  - RPMS
  - SOURCES
  - SPECS
  - SRPMS
</code></pre>
<p>The <code>BUILD</code> and <code>BUILDROOT</code> subdirectories are used for compiling the source code and collecting the necessary installed files for packaging, respectively. The <code>SOURCES</code> subdirectory contains the source files, including any patches, and <code>SPECS</code> contains the all-important spec files, which instruct the <code>rpmbuild</code> utility how to build the package and what metadata the RPM should contain. The RPM is stored in the <code>RPMS</code> subdirectory and the SRPM is stored in the <code>SRPMS</code> subdirectory.</p>
<p>spec files look sort of like PKGBUILDs, except they use macros instead of many of the variables and functions found in PKGBUILDs. I would provide an example here in this post of Vim’s spec file (the one I use to build Vim in the Open Build Service) but it is over 520 lines long (as opposed to 72 lines for the gVim PKGBUILD shown earlier). So to view it see <a href="https://build.opensuse.org/package/view_file/home:fusion809/vim/vim.spec?expand=1">here</a>. I personally find writing spec files significantly more complicated than writing PKGBUILDs, as PKGBUILDs are written more like as if you were writing a shell script to install the software package locally on your machine. The use of macros can make things more complicated to follow for package development newcomers.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
